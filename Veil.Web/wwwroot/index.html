<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8"/>
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport"/>
    <title>Veil of Cataclysm</title>
    <base href="./"/>
    <link href="css/bootstrap/bootstrap.min.css" rel="stylesheet"/>
    <link href="css/app.css" rel="stylesheet"/>
    <link href="css/loading.css" rel="stylesheet"/>
    <link href="Veil.Web.styles.css" rel="stylesheet"/>
</head>

<body>

<div id="app">
    <div class="loading-crt" id="loading">
        <div class="loading-inner">
            <div>
                <img alt="Veil of Cataclysm" src="TitleOnlyTransparent.png"/>
            </div>
            <div aria-label="Loading" class="spinner-border" role="status"></div>
        </div>
    </div>
</div>

<div id="blazor-error-ui">
    An unhandled error has occurred.
    <a class="reload" href="">Reload</a>
    <a class="dismiss">x</a>
</div>

<script autostart="false" src="_framework/blazor.webassembly.js"></script>
<script type="module">
    import {BrotliDecode} from './js/decode.min.js';

    window.BrotliDecode = BrotliDecode;
    // Set this to enable Brotli (.br) decompression on static webServers
    // that don't support content compression and http://.
    var enableBrotliDecompression = false;
    Blazor.start({
        loadBootResource: function (type, name, defaultUri, integrity) {
            if (enableBrotliDecompression === true && type !== 'dotnetjs' && location.hostname !== 'localhost') {
                return (async function () {
                    const response = await fetch(defaultUri + '.br', {cache: 'no-cache'});
                    if (!response.ok)
                        throw new Error(response.statusText);
                    const originalResponseBuffer = await response.arrayBuffer();
                    const originalResponseArray = new Int8Array(originalResponseBuffer);
                    const contentType = (type === 'dotnetwasm')
                        ? 'application/wasm'
                        : 'application/octet-stream';
                    const decompressedResponseArray = BrotliDecode(originalResponseArray);
                    return new Response(decompressedResponseArray,
                        {
                            headers: {'content-type': contentType}
                        });
                })();
            }
        }
    });
</script>

<script src="_content/nkast.Wasm.JSInterop/js/JSObject.8.0.11.js"></script>
<script src="_content/nkast.Wasm.Dom/js/Window.8.0.11.js"></script>
<script src="_content/nkast.Wasm.Dom/js/Document.8.0.11.js"></script>
<script src="_content/nkast.Wasm.Dom/js/Navigator.8.0.11.js"></script>
<script src="_content/nkast.Wasm.Dom/js/Gamepad.8.0.11.js"></script>
<script src="_content/nkast.Wasm.Dom/js/Media.8.0.11.js"></script>
<script src="_content/nkast.Wasm.XHR/js/XHR.8.0.11.js"></script>
<script src="_content/nkast.Wasm.Canvas/js/Canvas.8.0.11.js"></script>
<script src="_content/nkast.Wasm.Canvas/js/CanvasGLContext.8.0.11.js"></script>
<script src="_content/nkast.Wasm.Audio/js/Audio.8.0.11.js"></script>
<script src="_content/nkast.Wasm.XR/js/XR.8.0.11.js"></script>

<script>
    let lastCssW = 0, lastCssH = 0, lastDpr = 0;

    function resizeCanvasToHolder() {
        const canvas = document.getElementById('theCanvas');
        const holder = document.getElementById('canvasHolder');
        if (!canvas || !holder) return;

        const cssW = holder.clientWidth | 0;
        const cssH = holder.clientHeight | 0;
        const dpr = window.devicePixelRatio || 1;

        if (cssW <= 0 || cssH <= 0) return;

        // Only resize when something actually changed
        if (cssW === lastCssW && cssH === lastCssH && dpr === lastDpr) return;

        lastCssW = cssW;
        lastCssH = cssH;
        lastDpr = dpr;

        // Keep CSS size in logical pixels
        canvas.style.width = cssW + "px";
        canvas.style.height = cssH + "px";

        // Backing buffer in physical pixels
        canvas.width = Math.max(1, Math.floor(cssW * dpr));
        canvas.height = Math.max(1, Math.floor(cssH * dpr));
    }

    let stopped = false;

    async function tickJS() {
        if (stopped) return;

        try {
            resizeCanvasToHolder();
            await window.theInstance.invokeMethodAsync('TickDotNet');
            window.requestAnimationFrame(tickJS);
        } catch (e) {
            stopped = true;
            console.error("TickDotNet failed:", e);
            // no more requestAnimationFrame => no infinite loop
        }
    }

    window.initRenderJS = (instance) => {
        window.theInstance = instance;

        resizeCanvasToHolder();

        // disable context menu on right click
        const canvas = document.getElementById('theCanvas');
        canvas.addEventListener("contextmenu", e => e.preventDefault());

        // begin game loop
        window.requestAnimationFrame(tickJS);
    };

    window.addEventListener("keydown", function (event) {
        // Prevent Arrows Keys and Spacebar scrolling the outer page
        // when running inside an iframe. e.g: itch.io embedding.
        if ([32, 37, 38, 39, 40].indexOf(event.keyCode) > -1)
            event.preventDefault();
    });
    window.addEventListener("wheel", function (event) {
        // Prevent Mousewheel scrolling the outer page
        // when running inside an iframe. e.g: itch.io embedding.
        event.preventDefault();
    }, {passive: false});
</script>

<script src="js/veilAudio.js"></script>
<script src="js/veilGraphics.js"></script>

</body>

</html>
